js\config.js
---
// js/config.js

// Get quiz name from URL ?quiz=...
export function getQuizNameFromLocation() {
    const params = new URLSearchParams(window.location.search);
    const quiz = params.get('quiz');
    return quiz || 'amino-acids-v1';
}

// Resolve quiz JSON path from quizName
export function resolveQuizJsonPath(quizName) {
    return `data/quizzes/${quizName}.json`;
}

// Path to entry.json (quiz list)
export const ENTRY_JSON_PATH = 'data/entry.json';

---

js\dom-refs.js
---
// js/dom-refs.js

export const dom = {
    // 共通ヘッダ
    appTitle: document.getElementById('app-title'),
    appDescription: document.getElementById('app-description'),
    quizHeaderScore: document.getElementById('quiz-header-score'),

    // メイン側（左パネル）
    mainMenu: document.getElementById('main-menu'),
    mainQuiz: document.getElementById('main-quiz'),

    // メニュー（メイン）
    quizList: document.getElementById('quiz-list'),
    modeSelect: document.getElementById('mode-select'),
    startButton: document.getElementById('start-button'),

    // メニュー（サイド）
    sideMenu: document.getElementById('side-menu'),
    questionCountInput: document.getElementById('question-count'),
    menuThemeToggle: document.getElementById('theme-toggle-menu'),
    menuSizeSmall: document.getElementById('size-small-menu'),
    menuSizeMedium: document.getElementById('size-medium-menu'),
    menuSizeLarge: document.getElementById('size-large-menu'),

    // クイズ（メイン）
    mainQuizSection: document.getElementById('main-quiz'),
    currentQNum: document.getElementById('current-q-num'),
    totalQNum: document.getElementById('total-q-num'),
    currentScore: document.getElementById('current-score'),

    questionText: document.getElementById('question-text'),
    optionsContainer: document.getElementById('options-container'),
    nextButton: document.getElementById('next-button'),

    // クイズ（サイド）
    sideQuiz: document.getElementById('side-quiz'),
    reviewEmpty: document.getElementById('review-empty'),
    reviewList: document.getElementById('review-list'),
    mistakeCount: document.getElementById('mistake-count'),

    // クイズ中の設定（サイド）
    quizThemeToggle: document.getElementById('theme-toggle-quiz'),
    quizSizeSmall: document.getElementById('size-small-quiz'),
    quizSizeMedium: document.getElementById('size-medium-quiz'),
    quizSizeLarge: document.getElementById('size-large-quiz'),

    // 結果
    resultScreen: document.getElementById('result-screen'),
    resultScore: document.getElementById('result-score'),
    retryButton: document.getElementById('retry-button'),
    backToMenuButton: document.getElementById('back-to-menu-button')
};

---

js\entry-model.js
---
// js/entry-model.js
import { ENTRY_JSON_PATH } from './config.js';

export async function loadQuizEntries() {
    const res = await fetch(ENTRY_JSON_PATH);
    if (!res.ok) {
        throw new Error('Failed to load entry.json');
    }
    const json = await res.json();
    return json.quizzes || [];
}

---

js\main.js
---
// js/main.js
import { initThemeFromStorage, toggleTheme, setSize, initAppHeightObserver } from './theme.js';
import { dom } from './dom-refs.js';
import { loadQuizDefinition } from './quiz-model.js';
import { loadQuizEntries } from './entry-model.js';
import { renderQuizMenu } from './menu-renderer.js';
import { QuizEngine } from './quiz-engine.js';
import {
    renderQuestionText,
    renderOptions,
    renderProgress,
    showOptionFeedback,
    resetReviewList,
    addReviewItem
} from './quiz-renderer.js';

let quizDef = null;
let quizEntries = [];
let engine = null;

let totalQuestions = 10;
let currentIndex = 0;
let currentScore = 0;
let currentQuestion = null;
let hasAnswered = false;

// 画面切り替え: "menu" / "quiz" / "result"
function showScreen(name) {
    // メイン
    dom.mainMenu.classList.add('hidden');
    dom.mainQuiz.classList.add('hidden');

    // サイド
    dom.sideMenu.classList.add('hidden');
    dom.sideQuiz.classList.add('hidden');

    // ヘッダスコア
    dom.quizHeaderScore.classList.add('hidden');

    // 結果パネル
    dom.resultScreen.classList.add('hidden');

    if (name === 'menu') {
        dom.mainMenu.classList.remove('hidden');
        dom.sideMenu.classList.remove('hidden');
    } else if (name === 'quiz') {
        dom.mainQuiz.classList.remove('hidden');
        dom.sideQuiz.classList.remove('hidden');
        dom.quizHeaderScore.classList.remove('hidden');
    } else if (name === 'result') {
        dom.mainQuiz.classList.remove('hidden');
        dom.sideQuiz.classList.remove('hidden');
        dom.quizHeaderScore.classList.remove('hidden');
        dom.resultScreen.classList.remove('hidden');
    }
}

function populateModeSelect() {
    dom.modeSelect.innerHTML = '';
    quizDef.modes.forEach((mode, idx) => {
        const opt = document.createElement('option');
        opt.value = mode.id;
        opt.textContent = mode.label || mode.id;
        if (idx === 0) opt.selected = true;
        dom.modeSelect.appendChild(opt);
    });
}

function startQuiz() {
    const modeId = dom.modeSelect.value;
    const n = parseInt(dom.questionCountInput.value, 10);
    totalQuestions = Number.isFinite(n) && n > 0 ? n : 10;

    currentIndex = 0;
    currentScore = 0;
    hasAnswered = false;
    dom.nextButton.disabled = true;

    engine.setMode(modeId);
    renderProgress(currentIndex, totalQuestions, currentScore);
    resetReviewList();

    showScreen('quiz');
    loadNextQuestion();
}

function loadNextQuestion() {
    if (currentIndex >= totalQuestions) {
        showResult();
        return;
    }

    hasAnswered = false;
    dom.nextButton.disabled = true;

    currentQuestion = engine.generateQuestion();
    const entity = quizDef.entitySet.entities[currentQuestion.entityId];

    renderQuestionText(currentQuestion.patternTokens, entity, true);
    renderOptions(currentQuestion, quizDef.entitySet, handleSelectOption);
    renderProgress(currentIndex, totalQuestions, currentScore);
}

function handleSelectOption(selectedIndex) {
    if (hasAnswered) return;
    hasAnswered = true;

    const correctIndex = currentQuestion.answer.correctIndex;
    if (selectedIndex === correctIndex) {
        currentScore += 1;
    } else {
        // 間違えた問題をサブエリアに追加
        addReviewItem(currentQuestion, quizDef.entitySet, currentIndex + 1);
    }

    showOptionFeedback(currentQuestion, selectedIndex);
    renderProgress(currentIndex, totalQuestions, currentScore);

    dom.nextButton.disabled = false;
}

function showResult() {
    dom.resultScore.textContent = `${currentScore} / ${totalQuestions}`;
    showScreen('result');
}

async function bootstrap() {
    initThemeFromStorage();
    initAppHeightObserver();

    try {
        const [def, entries] = await Promise.all([
            loadQuizDefinition(),
            loadQuizEntries()
        ]);
        quizDef = def;
        quizEntries = entries;

        document.title = quizDef.meta.title || '4-choice Quiz';
        dom.appTitle.textContent = quizDef.meta.title || '4-choice Quiz';
        dom.appDescription.textContent = quizDef.meta.description || '';

        renderQuizMenu(quizEntries);

        engine = new QuizEngine(quizDef);
        populateModeSelect();

        // --- メニュー側の設定ボタン ---
        if (dom.menuThemeToggle) {
            dom.menuThemeToggle.addEventListener('click', () => {
                toggleTheme();
            });
        }
        if (dom.menuSizeSmall) {
            dom.menuSizeSmall.addEventListener('click', () => setSize('s'));
        }
        if (dom.menuSizeMedium) {
            dom.menuSizeMedium.addEventListener('click', () => setSize('m'));
        }
        if (dom.menuSizeLarge) {
            dom.menuSizeLarge.addEventListener('click', () => setSize('l'));
        }

        // --- クイズ中（サイドパネル）の設定ボタン ---
        if (dom.quizThemeToggle) {
            dom.quizThemeToggle.addEventListener('click', () => {
                toggleTheme();
            });
        }
        if (dom.quizSizeSmall) {
            dom.quizSizeSmall.addEventListener('click', () => setSize('s'));
        }
        if (dom.quizSizeMedium) {
            dom.quizSizeMedium.addEventListener('click', () => setSize('m'));
        }
        if (dom.quizSizeLarge) {
            dom.quizSizeLarge.addEventListener('click', () => setSize('l'));
        }

        // --- クイズ開始 / 進行系 ---
        dom.startButton.addEventListener('click', startQuiz);

        dom.nextButton.addEventListener('click', () => {
            if (!hasAnswered) return;
            currentIndex += 1;
            loadNextQuestion();
        });

        dom.retryButton.addEventListener('click', () => {
            currentIndex = 0;
            currentScore = 0;
            hasAnswered = false;
            dom.nextButton.disabled = true;
            showScreen('quiz');
            loadNextQuestion();
        });

        dom.backToMenuButton.addEventListener('click', () => {
            showScreen('menu');
        });

        showScreen('menu');
    } catch (e) {
        console.error(e);
        dom.appDescription.textContent = 'Failed to load quiz definition.';
    }
}

bootstrap();

---

js\menu-renderer.js
---
// js/menu-renderer.js
import { dom } from './dom-refs.js';
import { getQuizNameFromLocation } from './config.js';

export function renderQuizMenu(entries) {
    const currentQuiz = getQuizNameFromLocation();
    dom.quizList.innerHTML = '';

    entries.forEach(entry => {
        const isCurrent = entry.id === currentQuiz;
        const a = document.createElement('a');
        a.href = `?quiz=${encodeURIComponent(entry.id)}`;
        a.className = [
            'block p-3 rounded-xl border text-xs',
            isCurrent
                ? 'border-emerald-400 bg-emerald-950/40'
                : 'border-slate-700 hover:border-emerald-400 hover:bg-slate-800/60'
        ].join(' ');

        a.innerHTML = `
            <div class="flex items-center justify-between gap-2">
                <div>
                    <div class="font-semibold">
                        ${entry.title}
                        ${isCurrent ? '<span class="ml-2 text-[10px] px-2 py-0.5 rounded-full bg-emerald-500/20 text-emerald-300">Current</span>' : ''}
                    </div>
                    <div class="mt-0.5 text-[10px] text-slate-400">
                        ${entry.description}
                    </div>
                </div>
                <div class="text-[10px] text-slate-500 text-right">
                    ${entry.difficulty || ''}
                </div>
            </div>
        `;
        dom.quizList.appendChild(a);
    });
}

---

js\quiz-engine.js
---
// js/quiz-engine.js

function randomChoice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

export class QuizEngine {
    constructor(definition) {
        this.meta = definition.meta;
        this.entitySet = definition.entitySet;
        this.patterns = definition.patterns;
        this.modes = definition.modes;
        this.entities = this.entitySet.entities || {};
        this.entityIds = Object.keys(this.entities);
        this.patternMap = new Map(this.patterns.map(p => [p.id, p]));
        this.currentMode = null;
        this.currentWeights = [];
    }

    setMode(modeId) {
        const mode = this.modes.find(m => m.id === modeId) || this.modes[0];
        this.currentMode = mode;
        const weights = mode.patternWeights || [];
        const list = [];
        let sum = 0;
        for (const pw of weights) {
            const p = this.patternMap.get(pw.patternId);
            if (!p) continue;
            sum += pw.weight;
            list.push({ pattern: p, cumulative: sum });
        }
        this.currentWeights = { list, total: sum };
    }

    _choosePattern() {
        const w = this.currentWeights;
        if (!w || !w.list.length || !w.total) {
            // fallback: random from all patterns
            return randomChoice(this.patterns);
        }
        const r = Math.random() * w.total;
        return w.list.find(x => r < x.cumulative).pattern;
    }

    _getRubyDisplayKey(hiderubyToken, entity) {
        const base = hiderubyToken.base;
        const ruby = hiderubyToken.ruby;
        const baseText = base.source === 'key'
            ? (entity[base.field] ?? '')
            : (base.value ?? '');
        const rubyText = ruby.source === 'key'
            ? (entity[ruby.field] ?? '')
            : (ruby.value ?? '');
        return `${baseText}|||${rubyText}`;
    }

    generateQuestion() {
        if (this.entityIds.length === 0 || this.patterns.length === 0) {
            throw new Error('No entities or patterns available');
        }

        const pattern = this._choosePattern();
        const entityId = randomChoice(this.entityIds);
        const entity = this.entities[entityId];

        // 採点対象となる hideruby を探す（今は1つを想定）
        const hiderubyToken = (pattern.tokens || []).find(
            t => t.type === 'hideruby' && t.answer && t.answer.mode === 'choice_ruby_pair'
        );
        if (!hiderubyToken) {
            throw new Error(`Pattern ${pattern.id} has no usable hideruby answer`);
        }

        const correctEntityId = entityId;
        const correctDisplayKey = this._getRubyDisplayKey(hiderubyToken, entity);

        const choiceCfg = hiderubyToken.answer.choice || {};
        const count = choiceCfg.distractorSource?.count ?? 3;
        const avoidSameId = !!choiceCfg.distractorSource?.avoidSameId;
        const avoidSameText = !!choiceCfg.distractorSource?.avoidSameText;

        const distractorIds = [];
        const usedIds = new Set([correctEntityId]);
        const usedTextKeys = new Set([correctDisplayKey]);

        // ダミー候補をランダムに選ぶ
        const pool = this.entityIds.slice();
        let safety = 1000;
        while (distractorIds.length < count && safety-- > 0) {
            const candidateId = randomChoice(pool);
            if (avoidSameId && candidateId === correctEntityId) continue;
            if (usedIds.has(candidateId)) continue;

            const candidateEntity = this.entities[candidateId];
            const key = this._getRubyDisplayKey(hiderubyToken, candidateEntity);
            if (avoidSameText && usedTextKeys.has(key)) continue;

            distractorIds.push(candidateId);
            usedIds.add(candidateId);
            usedTextKeys.add(key);
        }

        const optionEntities = [
            { entityId: correctEntityId, isCorrect: true, displayKey: correctDisplayKey },
            ...distractorIds.map(id => ({
                entityId: id,
                isCorrect: false,
                displayKey: this._getRubyDisplayKey(hiderubyToken, this.entities[id])
            }))
        ];

        // シャッフル
        for (let i = optionEntities.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [optionEntities[i], optionEntities[j]] = [optionEntities[j], optionEntities[i]];
        }

        const correctIndex = optionEntities.findIndex(o => o.isCorrect);

        return {
            patternId: pattern.id,
            patternTokens: pattern.tokens,
            entityId,
            answer: {
                type: 'choice_ruby_pair',
                hiderubyToken,
                options: optionEntities,
                correctIndex
            }
        };
    }
}

---

js\quiz-model.js
---
// js/quiz-model.js
import { getQuizNameFromLocation, resolveQuizJsonPath } from './config.js';

export async function loadQuizDefinition() {
    const quizName = getQuizNameFromLocation();
    const path = resolveQuizJsonPath(quizName);

    const res = await fetch(path);
    if (!res.ok) {
        throw new Error(`Failed to load quiz JSON: ${path}`);
    }
    const json = await res.json();

    return {
        quizName,
        meta: {
            id: json.id,
            title: json.title,
            description: json.description,
            colorHue: json.color
        },
        entitySet: json.entitySet,
        patterns: json.questionRules.patterns,
        modes: json.questionRules.modes
    };
}

---

js\quiz-renderer.js
---
// js/quiz-renderer.js
import { dom } from './dom-refs.js';

function createStyledSpan(text, styles = []) {
    const span = document.createElement('span');
    span.textContent = text;

    if (styles.includes('bold')) span.classList.add('font-semibold');
    if (styles.includes('italic')) span.classList.add('italic');
    if (styles.includes('serif')) span.classList.add('font-serif');
    if (styles.includes('sans')) span.classList.add('font-sans');

    if (styles.includes('katex')) {
        const raw = text;
        span.textContent = '';
        if (window.katex) {
            try {
                window.katex.render(raw, span, { throwOnError: false });
            } catch {
                span.textContent = raw;
            }
        } else {
            span.textContent = raw;
        }
    }

    return span;
}

function renderRubyToken(token, entity) {
    const base = token.base;
    const ruby = token.ruby;

    const baseText = base.source === 'key'
        ? (entity[base.field] ?? '')
        : (base.value ?? '');
    const rubyText = ruby.source === 'key'
        ? (entity[ruby.field] ?? '')
        : (ruby.value ?? '');

    const rubyEl = document.createElement('ruby');

    const rb = createStyledSpan(baseText, base.styles || []);
    const rtSpan = createStyledSpan(rubyText, ruby.styles || []);
    const rt = document.createElement('rt');
    rt.classList.add('text-[10px]');
    rt.appendChild(rtSpan);

    rubyEl.appendChild(rb);
    rubyEl.appendChild(rt);

    return rubyEl;
}

// ★ targetElement を指定できるように
export function renderQuestionText(patternTokens, entity, skipAnswerTokens = true, targetElement = dom.questionText) {
    targetElement.innerHTML = '';
    if (!patternTokens) return;

    patternTokens.forEach(token => {
        if (!token) return;

        // hideruby は選択肢専用にして、問題文には出さない
        if (skipAnswerTokens && token.type === 'hideruby') {
            return;
        }

        if (token.type === 'text') {
            const span = createStyledSpan(token.value ?? '', token.styles || []);
            targetElement.appendChild(span);
        } else if (token.type === 'key') {
            const value = entity[token.field] ?? '';
            const span = createStyledSpan(value, token.styles || []);
            targetElement.appendChild(span);
        } else if (token.type === 'ruby') {
            const rubyEl = renderRubyToken(token, entity);
            targetElement.appendChild(rubyEl);
        } else if (token.type === 'hide') {
            const span = createStyledSpan('____', token.styles || []);
            span.classList.add('px-2', 'border-b', 'border-slate-500');
            targetElement.appendChild(span);
        }
    });
}

function createRubyOptionButton(hiderubyToken, entity, onClick) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'w-full text-left px-3 py-2 rounded-xl border border-slate-700 bg-slate-900 hover:border-emerald-400 text-sm';
    const rubyEl = renderRubyToken(hiderubyToken, entity);
    btn.appendChild(rubyEl);
    btn.addEventListener('click', onClick);
    return btn;
}

export function renderOptions(question, entitySet, onSelectOption) {
    const entities = entitySet.entities || {};
    dom.optionsContainer.innerHTML = '';

    question.answer.options.forEach((opt, idx) => {
        const ent = entities[opt.entityId];
        const btn = createRubyOptionButton(question.answer.hiderubyToken, ent, () => {
            onSelectOption(idx);
        });
        btn.dataset.index = String(idx);
        dom.optionsContainer.appendChild(btn);
    });
}

export function showOptionFeedback(question, selectedIndex) {
    const correctIndex = question.answer.correctIndex;
    const buttons = Array.from(dom.optionsContainer.querySelectorAll('button'));

    buttons.forEach((btn, idx) => {
        btn.disabled = true;
        btn.classList.remove('hover:border-emerald-400');
        if (idx === correctIndex) {
            btn.classList.add('border-emerald-400', 'bg-emerald-900/40');
        }
        if (idx === selectedIndex && idx !== correctIndex) {
            btn.classList.add('border-red-400', 'bg-red-900/40');
        }
    });
}

export function renderProgress(currentIndex, total, score) {
    dom.currentQNum.textContent = String(currentIndex + 1);
    dom.totalQNum.textContent = String(total);
    dom.currentScore.textContent = String(score);
}

/* ========= レビューリスト（サブエリア） ========= */

export function resetReviewList() {
    if (!dom.reviewList || !dom.reviewEmpty || !dom.mistakeCount) return;
    dom.reviewList.innerHTML = '';
    dom.reviewList.classList.add('hidden');
    dom.reviewEmpty.classList.remove('hidden');
    dom.mistakeCount.classList.add('hidden');
    dom.mistakeCount.textContent = '0';
}

export function addReviewItem(questionInstance, entitySet, questionNumber) {
    if (!dom.reviewList || !dom.reviewEmpty || !dom.mistakeCount) return;

    const entity = entitySet.entities[questionInstance.entityId];
    const tmp = document.createElement('div');
    // 質問文を HTML として再生成
    renderQuestionText(questionInstance.patternTokens, entity, true, tmp);
    const questionHtml = tmp.innerHTML;

    dom.reviewEmpty.classList.add('hidden');
    dom.reviewList.classList.remove('hidden');

    const li = document.createElement('li');
    li.className = 'bg-slate-900/60 border border-slate-700 rounded-xl p-3 text-xs space-y-1 fade-in';

    li.innerHTML = `
        <div class="text-[10px] text-slate-400">Q${questionNumber} mistake</div>
        <div class="text-slate-100">${questionHtml}</div>
    `;

    // 先頭に追加
    dom.reviewList.prepend(li);

    // カウント更新
    const count = parseInt(dom.mistakeCount.textContent || '0', 10) + 1;
    dom.mistakeCount.textContent = String(count);
    dom.mistakeCount.classList.remove('hidden');
}

---

js\theme.js
---
// js/theme.js

const THEME_KEY = 'quiz_theme';
const SCALE_KEY = 'quiz_scale';

const SCALE_MAP = {
    s: 0.85,
    m: 1.0,
    l: 1.2
};

export function initThemeFromStorage() {
    // --- Theme ---
    const savedTheme = localStorage.getItem(THEME_KEY);
    const prefersDark = window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches;

    const useDark = savedTheme
        ? savedTheme === 'dark'
        : prefersDark;

    if (useDark) {
        document.documentElement.classList.add('dark');
        document.body.classList.add('bg-slate-950', 'text-slate-100');
        document.body.classList.remove('bg-slate-50', 'text-slate-900');
    } else {
        document.documentElement.classList.remove('dark');
        document.body.classList.add('bg-slate-50', 'text-slate-900');
        document.body.classList.remove('bg-slate-950', 'text-slate-100');
    }

    // --- Font scale ---
    const savedScale = localStorage.getItem(SCALE_KEY) || 'm';
    const scale = SCALE_MAP[savedScale] || 1.0;
    document.documentElement.style.setProperty('--app-scale', scale);
}

export function toggleTheme() {
    const savedTheme = localStorage.getItem(THEME_KEY);
    const next = savedTheme === 'light' ? 'dark' : 'light';
    localStorage.setItem(THEME_KEY, next);
    initThemeFromStorage();
}

export function setSize(size) {
    const scale = SCALE_MAP[size] || 1.0;
    localStorage.setItem(SCALE_KEY, size);
    document.documentElement.style.setProperty('--app-scale', scale);
}

// モバイルブラウザでアドレスバー分を引いた高さを使う
export function initAppHeightObserver() {
    const setAppHeight = () => {
        document.documentElement.style.setProperty('--app-height', `${window.innerHeight}px`);
    };
    window.addEventListener('resize', setAppHeight);
    setAppHeight();
}

---

